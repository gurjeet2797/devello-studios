## Masks: Debug and Processing (Integration Notes)

This document consolidates the mask semantics and processing pipeline we used for precision editing, with concrete, copy-pasteable snippets and operational guidance.

### 1) Mask Semantics (Flux Fill Pro)
- Black (0) = preserve/freeze; White (255) = inpaint/edit.
- Use a binary mask (no greys) for predictable results.
- Mask resolution must exactly match the input image after normalization.
- File types: jpg/png/webp/gif. Prefer PNG for masks (lossless, exact values).

### 2) Image Normalization (critical for alignment)
Always normalize the input image before creating the mask so dimensions/orientation match:

```js
// Pseudocode with sharp
let imageBuffer = await fetchBuffer(imageUrlOrDataUrl);
imageBuffer = await sharp(imageBuffer).rotate().toBuffer(); // honor EXIF
try { imageBuffer = await sharp(imageBuffer).jpeg({ quality: 95 }).toBuffer(); } catch (_) {}
const { width, height } = await sharp(imageBuffer).metadata();
```

Use the resulting `width`/`height` for mask creation. Build/upload mask only after this step.

### 3) Creating a Binary Rectangular Mask from Hotspots
Hotspots are percent-based; convert to pixels and composite white rectangles onto a black, opaque canvas.

```js
import sharp from 'sharp';

async function createRectMask(width, height, hotspots) {
  // Opaque black canvas
  let mask = await sharp({
    create: { width, height, channels: 4, background: { r: 0, g: 0, b: 0, alpha: 255 } }
  }).png().toBuffer();

  for (const h of hotspots) {
    const left = Math.round((h.left / 100) * width);
    const top = Math.round((h.top / 100) * height);
    const w = Math.round((h.width / 100) * width);
    const hgt = Math.round((h.height / 100) * height);
    const whiteRect = await sharp({
      create: { width: Math.max(1, w), height: Math.max(1, hgt), channels: 4, background: { r: 255, g: 255, b: 255, alpha: 255 } }
    }).png().toBuffer();
    mask = await sharp(mask).composite([{ input: whiteRect, left: Math.max(0, left), top: Math.max(0, top) }]).png().toBuffer();
  }

  return mask; // PNG buffer
}
```

Tip: If you see spillover at the very edge, shrink each rect by 1px on each side inside image bounds.

### 4) Prompt Strategy for Masked Edits
Build a clear, structured prompt listing regions and global constraints. Example:

```text
Apply the following targeted edits to the image:

- Region 1 (46.3%, 41.5%, 10.0% × 10.0%): change stone to black marble
- Region 2 (74.0%, 18.3%, 10.0% × 10.0%): add a vase
- Region 3 (74.1%, 71.7%, 10.0% × 10.0%): add cleaning supplies

Edit ONLY within the white masked regions. Do not modify any pixels outside the mask. Maintain the original image composition, geometry, and camera angle. Output must match the input resolution exactly. Preserve realistic lighting and consistent style.
```

### 5) Calling the Model (Flux Fill Pro)
Use public HTTPS URLs for both image and mask. Pin version via env in production if needed.

```js
// sketch – replace with your client wrapper
const model = process.env.REPLICATE_FLUX_FILL_PRO_VERSION
  ? `black-forest-labs/flux-fill-pro:${process.env.REPLICATE_FLUX_FILL_PRO_VERSION}`
  : 'black-forest-labs/flux-fill-pro';

const input = {
  image: publicImageUrl,
  mask: publicMaskUrl,
  prompt: finalPrompt,
  steps: 30,             // 15–50; 30 is a good baseline
  guidance: 50,          // 2–100; increase to adhere more strictly to prompt
  output_format: 'jpg',  // jpg or png
  safety_tolerance: 3    // 1–6; 3–4 typical
};

const result = await replicate.run(model, { input });
const outputUrl = Array.isArray(result) ? (result[0]?.url || result[0]) : (result.url || result.output);
```

If the API returns non-URL shapes, pick the first string/URL-like field. Log errors verbosely in development.

### 6) Uploading Image and Mask to Public URLs
If your API requires public URLs, upload normalized image and generated mask to storage (e.g., Supabase) and fetch their public URLs before inference.

```js
const upImage = await supabase.storage.from('images').upload(imageName, imageBuffer, { contentType: 'image/jpeg' });
const { data: pubImage } = supabase.storage.from('images').getPublicUrl(imageName);
const upMask = await supabase.storage.from('images').upload(maskName, maskBuffer, { contentType: 'image/png' });
const { data: pubMask } = supabase.storage.from('images').getPublicUrl(maskName);
```

### 7) Debugging Aids
- Save the generated mask PNG to `debug-masks/` with timestamped filenames.
- Log: image dimensions (post-normalization), mask size, and first ~100 chars of data URL when useful.
- Log both public URLs (image/mask) passed to the model.

```js
import fs from 'fs'; import path from 'path';
const dir = path.join(process.cwd(), 'debug-masks');
if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
fs.writeFileSync(path.join(dir, `mask-${Date.now()}.png`), maskBuffer);
```

### 8) Optional: Region Cropping (for non-mask models or fallback)
If a fallback model needs region-wise processing (e.g., VLM), crop padded regions around hotspots, process independently, then stitch back:

```js
// Crop (with padding for context)
const padded = {
  left: Math.max(0, left - pad), top: Math.max(0, top - pad),
  width: Math.min(imgW - (left - pad), w + 2*pad), height: Math.min(imgH - (top - pad), h + 2*pad)
};
const cropped = await sharp(imageBuffer).extract(padded).png().toBuffer();

// ... process cropped ...

// Stitch: resize processed region to original region size and composite at original coordinates
const resized = await sharp(processed).resize(regionW, regionH, { fit: 'fill' }).png().toBuffer();
const stitched = await sharp(base).composite([{ input: resized, left: regionLeft, top: regionTop }]).png().toBuffer();
```

### 9) Failure Modes & Fixes
- Edits land outside hotspot: ensure rotate+normalize first; mask built with the same post-normalization `width`/`height`.
- No output / 500: use a pinned model version; log the error body; verify public URLs are fetchable.
- Leakage outside box: enforce hard binary mask; optionally inset mask by 1px.
- Overly literal or too loose: adjust `guidance` (↑ stricter, ↓ freer). Increase `steps` for detail.

### 10) Minimal Checklist
- Normalize image (rotate, convert) → read dims
- Build binary mask at exact dims
- Upload both to public URLs
- Build structured prompt with region list + global constraints
- Call model with stable version and tuned params
- Save mask in `debug-masks/` for audit


